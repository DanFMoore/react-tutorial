/**
 * This file provided by Facebook is for non-commercial testing and evaluation
 * purposes only. Facebook reserves all rights not expressly granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

var templates = require('./templates.jsx');
var React = require('react');
var marked = require('marked');
var $ = require('jquery');
var classNames = require('classnames');

var validation = require('react-validation-mixin');
var Validator = require('validatorjs');

var Comment = React.createClass({
    displayName: 'Comment',
    rawMarkup: function () {
        var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
        return {__html: rawMarkup};
    },

    render: templates.comment
});

var CommentBox = React.createClass({
    displayName: 'CommentBox',
    loadCommentsFromServer: function () {
        $.get(this.props.url).then(
            (data) => {
                this.setState({data: data});
            },
            (err) => {
                console.error(this.props.url, err);
            }
        );
    },
    handleCommentSubmit: function (comment) {
        var comments = this.state.data;
        // Optimistically set an id on the new comment. It will be replaced by an
        // id generated by the server. In a production application you would likely
        // not use Date.now() for this and would have a more robust system in place.
        comment.id = Date.now();
        var newComments = comments.concat([comment]);
        this.setState({data: newComments});

        $.ajax({
            url: this.props.url,
            dataType: 'json',
            type: 'POST',
            data: comment,
            success: (data) => {
                this.setState({data: data});
            },
            error: function (xhr, status, err) {
                this.setState({data: comments});
                console.error(this.props.url, status, err.toString());
            }.bind(this)
        });
    },
    getInitialState: function () {
        return {data: this.props.comments};
    },
    componentDidMount: function () {
        this.loadCommentsFromServer();
        setInterval(this.loadCommentsFromServer, this.props.pollInterval);
    },
    render: function () {
        return templates.commentBox.apply(this, [CommentList, CommentForm]);
    }
});

var CommentList = React.createClass({
    displayName: 'CommentList',
    render: function () {
        return templates.commentList.apply(this, [Comment]);
    }
});

var CommentForm = React.createClass({
    displayName: 'CommentForm',
    getInitialState: function () {
        // Define the rules and custom messages for each field.
        // Do this by creating a validator with no data; it's added later.
        this.validatorTypes = new Validator(
            {},
            {

            },
            {
                'min.text': 'Enter a message between 10 and 50 characters',
                'max.text': 'Enter a message between 10 and 50 characters'
            }
        );

        return {author: '', text: ''};
    },
    addValidation: function(e) {
        this.validatorTypes.rules = this.validatorTypes._parseRules({
            author: 'required',
            text: 'required|min:10|max:50'
        });

        this.props.handleValidation('author')(e);
        this.props.handleValidation('text')(e);
    },
    handleAuthorChange: function (e) {
        this.setState({author: e.target.value}, () => {
            this.props.handleValidation('author')(e);
        });
    },
    handleTextChange: function (e) {
        this.setState({text: e.target.value}, () => {
            this.props.handleValidation('text')(e);
        });
    },
    handleSubmit: function (e) {
        e.preventDefault();

        // If the form is valid, then submit the comment
        this.props.validate((error) => {
            if (!error) {
                this.props.onCommentSubmit(this.state);
                this.setState({author: '', text: ''});
            }
        });
    },
    getValidatorData: function () {
        return this.state;
    },
    getClasses: function (field) {
        return classNames({
            'has-error': !this.props.isValid(field)
        });
    },
    render: templates.commentForm
});

var strategy = {
    /**
     * Validate using the validatorjs library
     *
     * @see https://www.npmjs.com/package/validatorjs
     *
     * @param {Object} data the data submitted
     * @param {Validator} validator the validatorjs validator
     * @param {Object} options contains name of element being validated and previous errors
     * @param {Function} callback called and passed the errors
     */
    validate: function(data, validator, options, callback) {
        // Set the data again on the validator and clear existing errors
        validator.input = data;
        validator.errors.errors = {};

        var getErrors = () => {
            if (options.key) {
                options.prevErrors[options.key] = validator.errors.get(options.key);
                callback(options.prevErrors);
            } else {
                callback(validator.errors.all());
            }
        };

        // Run the validator asynchronously in case any async rules have been added
        validator.checkAsync(getErrors, getErrors);
    }
};

CommentForm = validation(strategy)(CommentForm);

module.exports = {
    Comment,
    CommentBox,
    CommentList,
    CommentForm
};
