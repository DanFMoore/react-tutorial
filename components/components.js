/**
 * This file provided by Facebook is for non-commercial testing and evaluation
 * purposes only. Facebook reserves all rights not expressly granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

var templates = require('./templates.jsx');
var React = require('react');
var marked = require('marked');
var $ = require('jquery');
var classNames = require('classnames');

var validation = require('react-validation-mixin');
var Validator = require('validatorjs');

var Comment = React.createClass({
    displayName: 'Comment',
    rawMarkup: function () {
        var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
        return {__html: rawMarkup};
    },

    render: templates.comment
});

var CommentBox = React.createClass({
    displayName: 'CommentBox',
    loadCommentsFromServer: function () {
        $.get(this.props.url).then(
            (data) => {
                this.setState({data: data});
            },
            (err) => {
                console.error(this.props.url, err);
            }
        );
    },
    handleCommentSubmit: function (comment) {
        var comments = this.state.data;
        // Optimistically set an id on the new comment. It will be replaced by an
        // id generated by the server. In a production application you would likely
        // not use Date.now() for this and would have a more robust system in place.
        comment.id = Date.now();
        var newComments = comments.concat([comment]);
        this.setState({data: newComments});

        $.ajax({
            url: this.props.url,
            dataType: 'json',
            type: 'POST',
            data: comment,
            success: (data) => {
                this.setState({data: data});
            },
            error: function (xhr, status, err) {
                this.setState({data: comments});
                console.error(this.props.url, status, err.toString());
            }.bind(this)
        });
    },
    getInitialState: function () {
        return {data: this.props.comments};
    },
    componentDidMount: function () {
        this.loadCommentsFromServer();
        setInterval(this.loadCommentsFromServer, this.props.pollInterval);
    },
    render: function () {
        return templates.commentBox.apply(this, [CommentList, CommentForm]);
    }
});

var CommentList = React.createClass({
    displayName: 'CommentList',
    render: function () {
        return templates.commentList.apply(this, [Comment]);
    }
});

var CommentForm = React.createClass({
    displayName: 'CommentForm',
    getInitialState: function () {
        // Define the rules and custom messages for each field.
        this.validatorTypes = strategy.createInactiveSchema(
            {
                author: 'required',
                text: 'required|min:10|max:50'
            },
            {
                //'min.text': 'Enter a message between 10 and 50 characters',
                //'max.text': 'Enter a message between 10 and 50 characters'
            }
        );

        return {author: '', text: ''};
    },
    addValidation: function(e) {
        strategy.activateRule(this.validatorTypes, e.target.name);
        this.props.handleValidation(e.target.name)(e);
    },
    handleChange: function (e) {
        var state = {};
        state[e.target.name] = e.target.value;

        this.setState(state, () => {
            this.props.handleValidation(e.target.name)(e);
        });
    },
    handleSubmit: function (e) {
        e.preventDefault();

        // If the form is valid, then submit the comment
        this.props.validate((error) => {
            if (!error) {
                this.props.onCommentSubmit(this.state);
                this.setState({author: '', text: ''});
            }
        });
    },
    getValidatorData: function () {
        return this.state;
    },
    getClasses: function (field) {
        return classNames({
            'has-error': !this.props.isValid(field)
        });
    },
    render: templates.commentForm
});

var strategy = {
    createSchema: function (rules, messages, createValidatorCallback) {
        return {
            rules,
            messages,
            createValidatorCallback
        };
    },
    createInactiveSchema: function (rules, messages, createValidatorCallback) {
        var schema = this.createSchema(rules, messages, createValidatorCallback);
        schema.activeRules = [];

        return schema;
    },
    activateRule: function(schema, rule) {
        if (schema.activeRules.indexOf(rule) === -1) {
            schema.activeRules.push(rule);
        }
    },
    /**
     * Validate using the validatorjs library
     *
     * @see https://www.npmjs.com/package/validatorjs
     *
     * @param {Object} data the data submitted
     * @param {Object} schema contains rules and custom error messages
     * @param {Object} options contains name of element being validated and previous errors
     * @param {Function} callback called and passed the errors
     */
    validate: function (data, schema, options, callback) {
        var rules = {};

        // Only add active rules to the validator if an initially inactive schema has been created.
        // Check all rules regardless if the form has been submitted (options.key is empty).
        if (typeof schema.activeRules !== 'undefined' && options.key) {
            for (let i in schema.activeRules) {
                let ruleName = schema.activeRules[i];

                rules[ruleName] = schema.rules[ruleName];
            }
        } else {
            rules = schema.rules;
        }

        var validator = new Validator(data, rules, schema.messages);

        if (typeof schema.createValidatorCallback === 'function') {
            schema.createValidatorCallback(validator);
        }

        var getErrors = () => {
            if (options.key) {
                options.prevErrors[options.key] = validator.errors.get(options.key);
                callback(options.prevErrors);
            } else {
                callback(validator.errors.all());
            }
        };

        // Run the validator asynchronously in case any async rules have been added
        validator.checkAsync(getErrors, getErrors);
    }
};

CommentForm = validation(strategy)(CommentForm);

module.exports = {
    Comment,
    CommentBox,
    CommentList,
    CommentForm
};
