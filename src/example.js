/**
 * This file provided by Facebook is for non-commercial testing and evaluation
 * purposes only. Facebook reserves all rights not expressly granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

var templates = require('./templates.jsx');
var React = require('react');
var marked = require('marked');

var ReactDOMServer = typeof window === "undefined" ? require('react-dom/server') : undefined;

var Comment = React.createClass({
    displayName: 'Comment',
    rawMarkup: function () {
        var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
        return {__html: rawMarkup};
    },

    render: templates.comment
});

var CommentBox = React.createClass({
    displayName: 'CommentBox',
    loadCommentsFromServer: function () {
        $.get(this.props.url).then(
            (data) => {
                this.setState({data: data});
            },
            (err) => {
                console.error(this.props.url, err.status, err.statusText);
            }
        );
    },
    handleCommentSubmit: function (comment) {
        var comments = this.state.data;
        // Optimistically set an id on the new comment. It will be replaced by an
        // id generated by the server. In a production application you would likely
        // not use Date.now() for this and would have a more robust system in place.
        comment.id = Date.now();
        var newComments = comments.concat([comment]);
        this.setState({data: newComments});

        $.ajax({
            url: this.props.url,
            dataType: 'json',
            type: 'POST',
            data: comment,
            success: (data) => {
                this.setState({data: data});
            },
            error: function (xhr, status, err) {
                this.setState({data: comments});
                console.error(this.props.url, status, err.toString());
            }.bind(this)
        });
    },
    getInitialState: function () {
        return {data: this.props.comments};
    },
    componentDidMount: function () {
        this.loadCommentsFromServer();
        setInterval(this.loadCommentsFromServer, this.props.pollInterval);
    },
    render: function () {
        return templates.commentBox.apply(this, [CommentList, CommentForm]);
    }
});

var CommentList = React.createClass({
    displayName: 'CommentList',
    render: function () {
        return templates.commentList.apply(this, [Comment]);
    }
});

var CommentForm = React.createClass({
    displayName: 'CommentForm',
    getInitialState: function () {
        return {author: '', text: ''};
    },
    handleAuthorChange: function (e) {
        this.setState({author: e.target.value});
    },
    handleTextChange: function (e) {
        this.setState({text: e.target.value});
    },
    handleSubmit: function (e) {
        e.preventDefault();
        var author = this.state.author.trim();
        var text = this.state.text.trim();
        if (!text || !author) {
            return;
        }
        this.props.onCommentSubmit({author: author, text: text});
        this.setState({author: '', text: ''});
    },
    render: templates.commentForm
});


module.exports = {
    /**
     * Load the comments via AJAX before rendering the comment box with the DOM.
     * This will avoid the server rendered comments being replaced with nothing by JS.
     * If the AJAX call fails, then just render no comments after logging the error.
     */
    render: () => {
        var url = "/api/comments";

        $.get(url).then(
            (comments) => {
                return comments;
            },
            (err) => {
                console.error(this.props.url, err.status, err.statusText);
                return [];
            }
        )
        .always((comments) => {
            ReactDOM.render(React.createElement(CommentBox, {
                url: url,
                pollInterval: 2000,
                comments: comments
            }), document.getElementById('content'));
        });
    },
    /**
     * Just return a static string to render on the server
     *
     * @param {Array} comments
     * @returns {String}
     */
    renderServer: (comments) => {
        return ReactDOMServer.renderToString(React.createElement(CommentBox, {
            url: "/api/comments",
            pollInterval: 2000,
            comments: comments
        }));
    }
};
